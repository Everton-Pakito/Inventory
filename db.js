const DB_NAME="inventario_db";const DB_VER=1;function openDB(){return new Promise((r,j)=>{const q=indexedDB.open(DB_NAME,DB_VER);q.onupgradeneeded=()=>{const d=q.result;if(!d.objectStoreNames.contains("cache"))d.createObjectStore("cache");if(!d.objectStoreNames.contains("queue"))d.createObjectStore("queue",{keyPath:"id"});};q.onsuccess=()=>r(q.result);q.onerror=()=>j(q.error);});}export async function cacheSet(k,v){const d=await openDB();return new Promise((r,j)=>{const t=d.transaction("cache","readwrite");t.objectStore("cache").put(v,k);t.oncomplete=()=>r(true);t.onerror=()=>j(t.error);});}export async function cacheGet(k){const d=await openDB();return new Promise((r,j)=>{const t=d.transaction("cache","readonly");const q=t.objectStore("cache").get(k);q.onsuccess=()=>r(q.result??null);q.onerror=()=>j(q.error);});}export async function queueAdd(i){const d=await openDB();return new Promise((r,j)=>{const t=d.transaction("queue","readwrite");t.objectStore("queue").put(i);t.oncomplete=()=>r(true);t.onerror=()=>j(t.error);});}export async function queueList(){const d=await openDB();return new Promise((r,j)=>{const t=d.transaction("queue","readonly");const q=t.objectStore("queue").getAll();q.onsuccess=()=>r(q.result||[]);q.onerror=()=>j(q.error);});}export async function queueDelete(id){const d=await openDB();return new Promise((r,j)=>{const t=d.transaction("queue","readwrite");t.objectStore("queue").delete(id);t.oncomplete=()=>r(true);t.onerror=()=>j(t.error);});}